<!DOCTYPE html>
<html lang="Ch">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    
    <title>一万字详解 Redis Cluster Gossip 协议 | 程序员历小冰</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Redis Cluster Gossip 协议今天来讲一下 Reids Cluster 的 Gossip 协议和集群操作，文章的思维导图如下所示。  集群模式和 Gossip 简介对于数据存储领域，当数据量或者请求流量大到一定程度后，就必然会引入分布式。比如 Redis，虽然其单机性能十分优秀，但是因为下列原因时，也不得不引入集群。  单机无法保证高可用，需要引入多实例来提供高可用性 单机能够提供">
<meta name="keywords" content="redis">
<meta property="og:type" content="article">
<meta property="og:title" content="一万字详解 Redis Cluster Gossip 协议">
<meta property="og:url" content="http://remcarpediem.net/article/933c5a3a/index.html">
<meta property="og:site_name" content="程序员历小冰">
<meta property="og:description" content="Redis Cluster Gossip 协议今天来讲一下 Reids Cluster 的 Gossip 协议和集群操作，文章的思维导图如下所示。  集群模式和 Gossip 简介对于数据存储领域，当数据量或者请求流量大到一定程度后，就必然会引入分布式。比如 Redis，虽然其单机性能十分优秀，但是因为下列原因时，也不得不引入集群。  单机无法保证高可用，需要引入多实例来提供高可用性 单机能够提供">
<meta property="og:locale" content="Chinese">
<meta property="og:image" content="http://cdn.remcarpediem.net/2020-12-02-145951.jpg">
<meta property="og:image" content="http://cdn.remcarpediem.net/2020-12-02-145957.png">
<meta property="og:image" content="http://cdn.remcarpediem.net/2020-12-02-150006.png">
<meta property="og:image" content="http://cdn.remcarpediem.net/2020-12-02-150011.gif">
<meta property="og:image" content="http://cdn.remcarpediem.net/2020-12-02-150023.jpg">
<meta property="og:image" content="http://cdn.remcarpediem.net/2020-12-02-150030.png">
<meta property="og:image" content="http://cdn.remcarpediem.net/2020-12-02-150034.png">
<meta property="og:image" content="http://cdn.remcarpediem.net/2020-12-02-150039.png">
<meta property="og:image" content="http://cdn.remcarpediem.net/2020-12-02-150044.png">
<meta property="og:image" content="http://cdn.remcarpediem.net/2020-12-02-150048.png">
<meta property="og:image" content="http://cdn.remcarpediem.net/2020-12-02-150053.png">
<meta property="og:image" content="http://cdn.remcarpediem.net/2020-05-26-144752.png">
<meta property="og:updated_time" content="2020-12-02T15:04:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一万字详解 Redis Cluster Gossip 协议">
<meta name="twitter:description" content="Redis Cluster Gossip 协议今天来讲一下 Reids Cluster 的 Gossip 协议和集群操作，文章的思维导图如下所示。  集群模式和 Gossip 简介对于数据存储领域，当数据量或者请求流量大到一定程度后，就必然会引入分布式。比如 Redis，虽然其单机性能十分优秀，但是因为下列原因时，也不得不引入集群。  单机无法保证高可用，需要引入多实例来提供高可用性 单机能够提供">
<meta name="twitter:image" content="http://cdn.remcarpediem.net/2020-12-02-145951.jpg">
    

    
        <link rel="alternate" href="/atom.xml" title="程序员历小冰" type="application/atom+xml">
    

    
        <link rel="icon" href="/css/images/avatar.jpeg">
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
    
    
    
        
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f089a91a688633df563c08899e3d893e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
    


<link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css"></head>
</html>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">程序员历小冰</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">主页</a>
                
                    <a class="main-nav-link" href="/categories">分类</a>
                
                    <a class="main-nav-link" href="/archives">归档</a>
                
                    <a class="main-nav-link" href="/book">读书</a>
                
                    <a class="main-nav-link" href="/categories/plan">计划</a>
                
                    <a class="main-nav-link" href="/about">关于</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/avatar.jpeg">
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Buscar">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Entradas',
            PAGES: 'Pages',
            CATEGORIES: 'Categorias',
            TAGS: 'Etiquetas',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">主页</a></td>
                
                    <td><a class="main-nav-link" href="/categories">分类</a></td>
                
                    <td><a class="main-nav-link" href="/archives">归档</a></td>
                
                    <td><a class="main-nav-link" href="/book">读书</a></td>
                
                    <td><a class="main-nav-link" href="/categories/plan">计划</a></td>
                
                    <td><a class="main-nav-link" href="/about">关于</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Buscar">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile" class="profile-fixed">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/avatar.jpeg">
            <h2 id="name">历小冰</h2>
            <h3 id="title">后端开发工程师</h3>
            <span id="location"><i class="fa fa-map-marker"></i>中国，南京</span>
            <img id="wechat" src="/css/images/wechat_public.jpg">
            <a id="follow" target="_blank" href="/css/images/wechat_public.jpg">⬆关注公众号⬆</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                102
                <span>Entradas</span>
            </div>
            <div class="article-info-block">
                65
                <span>Etiquetas</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/ztelur" target="_blank" title="github" class="tooltip">
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/css/images/wechat.jpeg" target="_blank" title="wechat" class="tooltip">
                            <i class="fa fa-wechat"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/atom.xml" target="_blank" title="rss" class="tooltip">
                            <i class="fa fa-rss"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main"><article id="post-一万字详解-Redis-Cluster-Gossip-协议" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
            一万字详解 Redis Cluster Gossip 协议
        </h1>
    

                
                    <div class="article-meta">
                        
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/933c5a3a/">
            <time datetime="2020-12-02T15:03:11.000Z" itemprop="datePublished">2020-12-02</time>
        </a>
    </div>


                        
                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/redis/">redis</a>
    </div>

                    </div>
                
            </header>
        
        

        <div class="article-entry" itemprop="articleBody">
            
            
                
            
            
                <h1 id="Redis-Cluster-Gossip-协议"><a href="#Redis-Cluster-Gossip-协议" class="headerlink" title="Redis Cluster Gossip 协议"></a>Redis Cluster Gossip 协议</h1><p>今天来讲一下 Reids Cluster 的 Gossip 协议和集群操作，文章的思维导图如下所示。</p>
<p><img src="http://cdn.remcarpediem.net/2020-12-02-145951.jpg" alt="xmind"></p>
<h3 id="集群模式和-Gossip-简介"><a href="#集群模式和-Gossip-简介" class="headerlink" title="集群模式和 Gossip 简介"></a>集群模式和 Gossip 简介</h3><p><strong>对于数据存储领域，当数据量或者请求流量大到一定程度后，就必然会引入分布式</strong>。比如 Redis，虽然其单机性能十分优秀，但是因为下列原因时，也不得不引入集群。</p>
<ul>
<li>单机无法保证高可用，需要引入多实例来提供高可用性</li>
<li>单机能够提供高达 8W 左右的QPS，再高的QPS则需要引入多实例</li>
<li>单机能够支持的数据量有限，处理更多的数据需要引入多实例；</li>
<li>单机所处理的网络流量已经超过服务器的网卡的上限值，需要引入多实例来分流。</li>
</ul>
<p>有集群，集群往往需要维护一定的元数据，比如实例的ip地址，缓存分片的 slots 信息等，所以需要一套分布式机制来维护元数据的一致性。这类机制一般有两个模式：分散式和集中式</p>
<p>分散式机制将元数据存储在部分或者所有节点上，不同节点之间进行不断的通信来维护元数据的变更和一致性。Redis Cluster，Consul 等都是该模式。</p>
<p><img src="http://cdn.remcarpediem.net/2020-12-02-145957.png" alt="Gossip_model"></p>
<p>而集中式是将集群元数据集中存储在外部节点或者中间件上，比如 zookeeper。旧版本的 kafka 和 storm 等都是使用该模式。</p>
<p><img src="http://cdn.remcarpediem.net/2020-12-02-150006.png" alt="center_model"></p>
<p>两种模式各有优劣，具体如下表所示：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>集中式</td>
<td>数据更新及时，时效好，元数据的更新和读取，时效性非常好，一旦元数据出现了变更，立即就更新到集中式的外部节点中，其他节点读取的时候立即就可以感知到;</td>
<td>较大数据更新压力，更新压力全部集中在外部节点，作为单点影响整个系统</td>
</tr>
<tr>
<td>分散式</td>
<td>数据更新压力分散，元数据的更新比较分散，不是集中某一个节点，更新请求比较分散，而且有不同节点处理，有一定的延时，降低了并发压力</td>
<td>数据更新延迟，可能导致集群的感知有一定的滞后</td>
</tr>
</tbody>
</table>
<p>分散式的元数据模式有多种可选的算法进行元数据的同步，比如说 Paxos、Raft 和 Gossip。Paxos 和 Raft 等都需要全部节点或者大多数节点(超过一半)正常运行，整个集群才能稳定运行，而 Gossip 则不需要半数以上的节点运行。</p>
<p>Gossip 协议，顾名思义，就像流言蜚语一样，利用一种随机、带有传染性的方式，将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。对你来说，掌握这个协议不仅能很好地理解这种最常用的，实现最终一致性的算法，也能在后续工作中得心应手地实现数据的最终一致性。</p>
<p><img src="http://cdn.remcarpediem.net/2020-12-02-150011.gif" alt="Gossip_gif"></p>
<p>Gossip 协议又称 epidemic 协议（epidemic protocol），是基于流行病传播方式的节点或者进程之间信息交换的协议，在P2P网络和分布式系统中应用广泛，它的方法论也特别简单：</p>
<blockquote>
<p>在一个处于有界网络的集群里，如果每个节点都随机与其他节点交换特定信息，经过足够长的时间后，集群各个节点对该份信息的认知终将收敛到一致。</p>
</blockquote>
<p>这里的“特定信息”一般就是指集群状态、各节点的状态以及其他元数据等。Gossip协议是完全符合 BASE 原则，可以用在任何要求最终一致性的领域，比如分布式存储和注册中心。另外，它可以很方便地实现弹性集群，允许节点随时上下线，提供快捷的失败检测和动态负载均衡等。</p>
<p>此外，Gossip 协议的最大的好处是，即使集群节点的数量增加，每个节点的负载也不会增加很多，几乎是恒定的。这就允许 Redis Cluster 或者 Consul 集群管理的节点规模能横向扩展到数千个。</p>
<h3 id="Redis-Cluster-的-Gossip-通信机制"><a href="#Redis-Cluster-的-Gossip-通信机制" class="headerlink" title="Redis Cluster 的 Gossip 通信机制"></a>Redis Cluster 的 Gossip 通信机制</h3><p>Redis Cluster 是在 3.0 版本引入集群功能。为了让让集群中的每个实例都知道其他所有实例的状态信息，Redis 集群规定各个实例之间按照 Gossip 协议来通信传递信息。</p>
<p><img src="http://cdn.remcarpediem.net/2020-12-02-150023.jpg" alt="redis_cluster"></p>
<p>上图展示了主从架构的 Redis Cluster 示意图，其中实线表示节点间的主从复制关系，而虚线表示各个节点之间的 Gossip 通信。</p>
<p>Redis Cluster 中的每个节点都<strong>维护一份自己视角下的当前整个集群的状态</strong>，主要包括：</p>
<ol>
<li><em>当前集群状态</em></li>
<li><em>集群中各节点所负责的 slots信息，及其migrate状态</em></li>
<li><em>集群中各节点的master-slave状态</em></li>
<li>集群中各节点的存活状态及怀疑Fail状态</li>
</ol>
<p>也就是说上面的信息，就是集群中Node相互八卦传播流言蜚语的内容主题，而且比较全面，既有自己的更有别人的，这么一来大家都相互传，最终信息就全面而且一致了。</p>
<p>Redis Cluster 的节点之间会相互发送多种消息，较为重要的如下所示：</p>
<ul>
<li>MEET：通过「cluster meet ip port」命令，已有集群的节点会向新的节点发送邀请，加入现有集群，然后新节点就会开始与其他节点进行通信；</li>
<li>PING：节点按照配置的时间间隔向集群中其他节点发送 ping 消息，消息中带有自己的状态，还有自己维护的集群元数据，和部分其他节点的元数据；</li>
<li>PONG:  节点用于回应 PING 和 MEET 的消息，结构和 PING 消息类似，也包含自己的状态和其他信息，也可以用于信息广播和更新；</li>
<li>FAIL: 节点 PING 不通某节点后，会向集群所有节点广播该节点挂掉的消息。其他节点收到消息后标记已下线。</li>
</ul>
<p>Redis 的源码中 cluster.h 文件定义了全部的消息类型，代码为 redis 4.0版本。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-c">&#x2F;&#x2F; 注意，PING 、 PONG 和 MEET 实际上是同一种消息。
&#x2F;&#x2F; PONG 是对 PING 的回复，它的实际格式也为 PING 消息，
&#x2F;&#x2F; 而 MEET 则是一种特殊的 PING 消息，用于强制消息的接收者将消息的发送者添加到集群中（如果节点尚未在节点列表中的话）
#define CLUSTERMSG_TYPE_PING 0          &#x2F;* Ping 消息 *&#x2F;
#define CLUSTERMSG_TYPE_PONG 1          &#x2F;* Pong 用于回复Ping *&#x2F;
#define CLUSTERMSG_TYPE_MEET 2          &#x2F;* Meet 请求将某个节点添加到集群中 *&#x2F;
#define CLUSTERMSG_TYPE_FAIL 3          &#x2F;* Fail 将某个节点标记为 FAIL *&#x2F;
#define CLUSTERMSG_TYPE_PUBLISH 4       &#x2F;* 通过发布与订阅功能广播消息 *&#x2F;
#define CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST 5 &#x2F;* 请求进行故障转移操作，要求消息的接收者通过投票来支持消息的发送者 *&#x2F;
#define CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK 6     &#x2F;* 消息的接收者同意向消息的发送者投票 *&#x2F;
#define CLUSTERMSG_TYPE_UPDATE 7        &#x2F;* slots 已经发生变化，消息发送者要求消息接收者进行相应的更新 *&#x2F;
#define CLUSTERMSG_TYPE_MFSTART 8       &#x2F;* 为了进行手动故障转移，暂停各个客户端 *&#x2F;
#define CLUSTERMSG_TYPE_COUNT 9         &#x2F;* 消息总数 *&#x2F;
</code></pre>
<p>通过上述这些消息，集群中的每一个实例都能获得其它所有实例的状态信息。这样一来，即使有新节点加入、节点故障、Slot 变更等事件发生，实例间也可以通过 PING、PONG 消息的传递，完成集群状态在每个实例上的同步。下面，我们依次来看看几种常见的场景。</p>
<h4 id="定时-PING-PONG-消息"><a href="#定时-PING-PONG-消息" class="headerlink" title="定时 PING/PONG 消息"></a>定时 PING/PONG 消息</h4><p>Redis Cluster 中的节点都会定时地向其他节点发送 PING 消息，来交换各个节点状态信息，检查各个节点状态，包括在线状态、疑似下线状态 PFAIL 和已下线状态 FAIL。</p>
<p>Redis 集群的定时 PING/PONG 的工作原理可以概括成两点：</p>
<ul>
<li>一是，每个实例之间会按照一定的频率，从集群中随机挑选一些实例，把 PING 消息发送给挑选出来的实例，用来检测这些实例是否在线，并交换彼此的状态信息。PING 消息中封装了发送消息的实例自身的状态信息、部分其它实例的状态信息，以及 Slot 映射表。</li>
<li>二是，一个实例在接收到 PING 消息后，会给发送 PING 消息的实例，发送一个 PONG 消息。PONG 消息包含的内容和 PING 消息一样。</li>
</ul>
<p>下图显示了两个实例间进行 PING、PONG 消息传递的情况，其中实例一为发送节点，实例二是接收节点</p>
<p><img src="http://cdn.remcarpediem.net/2020-12-02-150030.png" alt="Gossip_PING"></p>
<h4 id="新节点上线"><a href="#新节点上线" class="headerlink" title="新节点上线"></a>新节点上线</h4><p>Redis Cluster 加入新节点时，客户端需要执行 CLUSTER MEET 命令，如下图所示。</p>
<p><img src="http://cdn.remcarpediem.net/2020-12-02-150034.png" alt="meet"></p>
<p>节点一在执行 CLUSTER MEET 命令时会首先为新节点创建一个 clusterNode 数据，并将其添加到自己维护的 clusterState 的 nodes 字典中。有关 clusterState 和 clusterNode 关系，我们在最后一节会有详尽的示意图和源码来讲解。</p>
<p>然后节点一会根据据 CLUSTER MEET 命令中的 IP 地址和端口号，向新节点发送一条 MEET 消息。新节点接收到节点一发送的MEET消息后，新节点也会为节点一创建一个 clusterNode 结构，并将该结构添加到自己维护的 clusterState 的 nodes 字典中。</p>
<p>接着，新节点向节点一返回一条PONG消息。节点一接收到节点B返回的PONG消息后，得知新节点已经成功的接收了自己发送的MEET消息。</p>
<p>最后，节点一还会向新节点发送一条 PING 消息。新节点接收到该条 PING 消息后，可以知道节点A已经成功的接收到了自己返回的P ONG消息，从而完成了新节点接入的握手操作。</p>
<p>MEET 操作成功之后，节点一会通过稍早时讲的定时 PING 机制将新节点的信息发送给集群中的其他节点，让其他节点也与新节点进行握手，最终，经过一段时间后，新节点会被集群中的所有节点认识。</p>
<h4 id="节点疑似下线和真正下线"><a href="#节点疑似下线和真正下线" class="headerlink" title="节点疑似下线和真正下线"></a>节点疑似下线和真正下线</h4><p>Redis Cluster 中的节点会定期检查已经发送 PING 消息的接收方节点是否在规定时间 ( cluster-node-timeout ) 内返回了 PONG 消息，如果没有则会将其标记为疑似下线状态，也就是 PFAIL 状态，如下图所示。</p>
<p><img src="http://cdn.remcarpediem.net/2020-12-02-150039.png" alt="pfail"></p>
<p>然后，节点一会通过 PING 消息，将节点二处于疑似下线状态的信息传递给其他节点，例如节点三。节点三接收到节点一的 PING 消息得知节点二进入 PFAIL 状态后，会在自己维护的 clusterState 的 nodes 字典中找到节点二所对应的 clusterNode 结构，并将主节点一的下线报告添加到 clusterNode 结构的 fail_reports 链表中。</p>
<p><img src="http://cdn.remcarpediem.net/2020-12-02-150044.png" alt="PING_FAIL"></p>
<p>随着时间的推移，如果节点十 (举个例子) 也因为 PONG 超时而认为节点二疑似下线了，并且发现自己维护的节点二的 clusterNode 的 fail_reports 中有<strong>半数以上的主节点数量的未过时的将节点二标记为 PFAIL 状态报告日志</strong>，那么节点十将会把节点二将被标记为已下线 FAIL 状态，并且节点十会<strong>立刻</strong>向集群其他节点广播主节点二已经下线的 FAIL 消息，所有收到 FAIL 消息的节点都会立即将节点二状态标记为已下线。如下图所示。</p>
<p><img src="http://cdn.remcarpediem.net/2020-12-02-150048.png" alt="fail"></p>
<p>需要注意的是，报告疑似下线记录是由时效性的，如果超过 cluster-node-timeout *2 的时间，这个报告就会被忽略掉，让节点二又恢复成正常状态。</p>
<h3 id="Redis-Cluster-通信源码实现"><a href="#Redis-Cluster-通信源码实现" class="headerlink" title="Redis Cluster 通信源码实现"></a>Redis Cluster 通信源码实现</h3><p>综上，我们了解了 Redis Cluster 在定时 PING/PONG、新节点上线、节点疑似下线和真正下线等环节的原理和操作流程，下面我们来真正看一下 Redis 在这些环节的源码实现和具体操作。</p>
<h4 id="涉及的数据结构体"><a href="#涉及的数据结构体" class="headerlink" title="涉及的数据结构体"></a>涉及的数据结构体</h4><p>首先，我们先来讲解一下其中涉及的数据结构，也就是上文提到的 ClusterNode 等结构。</p>
<p><strong>每个节点都会维护一个 clusterState 结构</strong>，表示当前集群的整体状态，它的定义如下所示。</p>
 
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-c">typedef struct clusterState {
    clusterNode *myself;  &#x2F;* 当前节点的clusterNode信息 *&#x2F;
    ....
    dict *nodes;          &#x2F;* name到clusterNode的字典 *&#x2F;
    ....
    clusterNode *slots[CLUSTER_SLOTS]; &#x2F;* slot 和节点的对应关系*&#x2F;
    ....
} clusterState;
</code></pre>
<p>它有三个比较关键的字段，具体示意图如下所示：</p>
<ul>
<li>myself 字段，是一个 clusterNode 结构，用来记录自己的状态；</li>
<li>nodes 字典，记录一个 name 到 clusterNode 结构的映射，以此来记录其他节点的状态；</li>
<li>slot 数组，记录slot 对应的节点 clusterNode结构。</li>
</ul>
<p><img src="http://cdn.remcarpediem.net/2020-12-02-150053.png" alt="redis_cluster"></p>
<p>clusterNode 结构<strong>保存了一个节点的当前状态</strong>，比如<strong>节点的创建时间、节点的名字、节点 当前的配置纪元、节点的IP地址和端口号等等</strong>。除此之外，clusterNode结构的 link 属性是一个clusterLink结构，该结构保存了连接节点所需的有关信息<strong>，比如</strong>套接字描述符，输入缓冲区和输出缓冲区。clusterNode 还有一个 fail_report 的列表，用来记录疑似下线报告。具体定义如下所示。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-cpp">typedef struct clusterNode {
    mstime_t ctime; &#x2F;* 创建节点的时间 *&#x2F;
    char name[CLUSTER_NAMELEN]; &#x2F;* 节点的名字 *&#x2F;
    int flags;      &#x2F;* 节点标识，标记节点角色或者状态，比如主节点从节点或者在线和下线 *&#x2F;
    uint64_t configEpoch; &#x2F;* 当前节点已知的集群统一epoch *&#x2F;
    unsigned char slots[CLUSTER_SLOTS&#x2F;8]; &#x2F;* slots handled by this node *&#x2F;
    int numslots;   &#x2F;* Number of slots handled by this node *&#x2F;
    int numslaves;  &#x2F;* Number of slave nodes, if this is a master *&#x2F;
    struct clusterNode **slaves; &#x2F;* pointers to slave nodes *&#x2F;
    struct clusterNode *slaveof; &#x2F;* pointer to the master node. Note that it
                                    may be NULL even if the node is a slave
                                    if we don&#39;t have the master node in our
                                    tables. *&#x2F;
    mstime_t ping_sent;      &#x2F;* 当前节点最后一次向该节点发送 PING 消息的时间 *&#x2F;
    mstime_t pong_received;  &#x2F;* 当前节点最后一次收到该节点 PONG 消息的时间 *&#x2F;
    mstime_t fail_time;      &#x2F;* FAIL 标志位被设置的时间 *&#x2F;
    mstime_t voted_time;     &#x2F;* Last time we voted for a slave of this master *&#x2F;
    mstime_t repl_offset_time;  &#x2F;* Unix time we received offset for this node *&#x2F;
    mstime_t orphaned_time;     &#x2F;* Starting time of orphaned master condition *&#x2F;
    long long repl_offset;      &#x2F;* 当前节点的repl便宜 *&#x2F;
    char ip[NET_IP_STR_LEN];  &#x2F;* 节点的IP 地址 *&#x2F;
    int port;                   &#x2F;* 端口 *&#x2F;
    int cport;                  &#x2F;* 通信端口，一般是端口+1000 *&#x2F;
    clusterLink *link;          &#x2F;* 和该节点的 tcp 连接 *&#x2F;
    list *fail_reports;         &#x2F;* 下线记录列表 *&#x2F;
} clusterNode;
</code></pre>
<p>clusterNodeFailReport 是记录节点下线报告的结构体， node 是报告节点的信息，而 time 则代表着报告时间。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-c">typedef struct clusterNodeFailReport {
    struct clusterNode *node;  &#x2F;* 报告当前节点已经下线的节点 *&#x2F;
    mstime_t time;             &#x2F;* 报告时间 *&#x2F;
} clusterNodeFailReport;
</code></pre>
<h4 id="消息结构体"><a href="#消息结构体" class="headerlink" title="消息结构体"></a>消息结构体</h4><p>了解了 Reids 节点维护的数据结构体后，我们再来看节点进行通信的消息结构体。 通信消息最外侧的结构体为 clusterMsg，它包括了很多消息记录信息，包括 RCmb 标志位，消息总长度，消息协议版本，消息类型；它还包括了发送该消息节点的记录信息，比如节点名称，节点负责的slot信息，节点ip和端口等；最后它包含了一个 clusterMsgData 来携带具体类型的消息。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-c">typedef struct {
    char sig[4];        &#x2F;* 标志位，&quot;RCmb&quot; (Redis Cluster message bus). *&#x2F;
    uint32_t totlen;    &#x2F;* 消息总长度 *&#x2F;
    uint16_t ver;       &#x2F;* 消息协议版本 *&#x2F;
    uint16_t port;      &#x2F;* 端口 *&#x2F;
    uint16_t type;      &#x2F;* 消息类型 *&#x2F;
    uint16_t count;     &#x2F;*  *&#x2F;
    uint64_t currentEpoch;  &#x2F;* 表示本节点当前记录的整个集群的统一的epoch，用来决策选举投票等，与configEpoch不同的是：configEpoch表示的是master节点的唯一标志，currentEpoch是集群的唯一标志。 *&#x2F;
    uint64_t configEpoch;   &#x2F;* 每个master节点都有一个唯一的configEpoch做标志，如果和其他master节点冲突，会强制自增使本节点在集群中唯一 *&#x2F;
    uint64_t offset;    &#x2F;* 主从复制偏移相关信息，主节点和从节点含义不同 *&#x2F;
    char sender[CLUSTER_NAMELEN]; &#x2F;* 发送节点的名称 *&#x2F;
    unsigned char myslots[CLUSTER_SLOTS&#x2F;8]; &#x2F;* 本节点负责的slots信息,16384&#x2F;8个char数组，一共为16384bit *&#x2F;
    char slaveof[CLUSTER_NAMELEN]; &#x2F;* master信息，假如本节点是slave节点的话，协议带有master信息 *&#x2F;
    char myip[NET_IP_STR_LEN];    &#x2F;* IP *&#x2F;
    char notused1[34];  &#x2F;* 保留字段 *&#x2F;
    uint16_t cport;      &#x2F;* 集群的通信端口 *&#x2F;
    uint16_t flags;      &#x2F;* 本节点当前的状态，比如 CLUSTER_NODE_HANDSHAKE、CLUSTER_NODE_MEET *&#x2F;
    unsigned char state; &#x2F;* Cluster state from the POV of the sender *&#x2F;
    unsigned char mflags[3]; &#x2F;* 本条消息的类型，目前只有两类：CLUSTERMSG_FLAG0_PAUSED、CLUSTERMSG_FLAG0_FORCEACK *&#x2F;
    union clusterMsgData data;
} clusterMsg;
</code></pre>
<p>clusterMsgData 是一个 union 结构体，它可以为 PING，MEET，PONG 或者 FAIL 等消息体。其中当消息为 PING、MEET 和 PONG 类型时，ping 字段是被赋值的，而是 FAIL 类型时，fail 字段是被赋值的。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-c">&#x2F;&#x2F; 注意这是 union 关键字
union clusterMsgData {
    &#x2F;* PING, MEET 或者 PONG 消息时，ping 字段被赋值 *&#x2F;
    struct {
        &#x2F;* Array of N clusterMsgDataGossip structures *&#x2F;
        clusterMsgDataGossip gossip[1];
    } ping;
    &#x2F;*  FAIL 消息时，fail 被赋值 *&#x2F;
    struct {
        clusterMsgDataFail about;
    } fail;
    &#x2F;&#x2F; .... 省略 publish 和 update 消息的字段
};
</code></pre>
<p>clusterMsgDataGossip 是 PING、PONG 和 MEET 消息的结构体，它会包括发送消息节点维护的其他节点信息，也就是上文中 clusterState 中 nodes 字段包含的信息，具体代码如下所示，你也会发现二者的字段是类似的。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-c">typedef struct {
	&#x2F;* 节点的名字，默认是随机的，MEET消息发送并得到回复后，集群会为该节点设置正式的名称*&#x2F;
    char nodename[CLUSTER_NAMELEN]; 
    uint32_t ping_sent; &#x2F;* 发送节点最后一次给接收节点发送 PING 消息的时间戳，收到对应 PONG 回复后会被赋值为0 *&#x2F;
    uint32_t pong_received; &#x2F;* 发送节点最后一次收到接收节点发送 PONG 消息的时间戳 *&#x2F;
    char ip[NET_IP_STR_LEN];  &#x2F;* IP address last time it was seen *&#x2F;
    uint16_t port;       &#x2F;* IP*&#x2F;       
    uint16_t cport;      &#x2F;* 端口*&#x2F;  
    uint16_t flags;      &#x2F;* 标识*&#x2F; 
    uint32_t notused1;   &#x2F;* 对齐字符*&#x2F;
} clusterMsgDataGossip;

typedef struct {
    char nodename[CLUSTER_NAMELEN]; &#x2F;* 下线节点的名字 *&#x2F;
} clusterMsgDataFail;
</code></pre>
<p>看完了节点维护的数据结构体和发送的消息结构体后，我们就来看看 Redis 的具体行为源码了。</p>
<h4 id="随机周期性发送PING消息"><a href="#随机周期性发送PING消息" class="headerlink" title="随机周期性发送PING消息"></a>随机周期性发送PING消息</h4><p>Redis 的 clusterCron 函数会被定时调用，每被执行10次，就会准备向随机的一个节点发送 PING 消息。</p>
<p>它会先随机的选出 5 个节点，然后从中选择最久没有与之通信的节点，调用 clusterSendPing 函数发送类型为 CLUSTERMSG_TYPE_PING 的消息</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-cpp">&#x2F;&#x2F; cluster.c 文件 
&#x2F;&#x2F; clusterCron() 每执行 10 次（至少间隔一秒钟），就向一个随机节点发送 gossip 信息
if (!(iteration % 10)) {
    int j;

    &#x2F;* 随机 5 个节点，选出其中一个 *&#x2F;
    for (j = 0; j &lt; 5; j++) {
        de = dictGetRandomKey(server.cluster-&gt;nodes);
        clusterNode *this = dictGetVal(de);

        &#x2F;* 不要 PING 连接断开的节点，也不要 PING 最近已经 PING 过的节点 *&#x2F;
        if (this-&gt;link == NULL || this-&gt;ping_sent != 0) continue;
        if (this-&gt;flags &amp; (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))
            continue;
        &#x2F;* 对比 pong_received 字段，选出更长时间未收到其 PONG 消息的节点(表示好久没有接受到该节点的PONG消息了) *&#x2F;
        if (min_pong_node == NULL || min_pong &gt; this-&gt;pong_received) {
            min_pong_node = this;
            min_pong = this-&gt;pong_received;
        }
    }
    &#x2F;* 向最久没有收到 PONG 回复的节点发送 PING 命令 *&#x2F;
    if (min_pong_node) {
        serverLog(LL_DEBUG,&quot;Pinging node %.40s&quot;, min_pong_node-&gt;name);
        clusterSendPing(min_pong_node-&gt;link, CLUSTERMSG_TYPE_PING);
    }
}
</code></pre>
<p>clusterSendPing 函数的具体行为我们后续再了解，因为该函数在其他环节也会经常用到</p>
<h4 id="节点加入集群"><a href="#节点加入集群" class="headerlink" title="节点加入集群"></a>节点加入集群</h4><p>当节点执行 CLUSTER MEET 命令后，会在自身给新节点维护一个 clusterNode 结构体，该结构体的 link 也就是TCP连接字段是 null，表示是新节点尚未建立连接。</p>
<p>clusterCron 函数中也会处理这些未建立连接的新节点，调用 createClusterLink 创立连接，然后调用 clusterSendPing 函数来发送 MEET 消息</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-cpp">&#x2F;* cluster.c clusterCron 函数部分,为未创建连接的节点创建连接 *&#x2F;
if (node-&gt;link == NULL) {
    int fd;
    mstime_t old_ping_sent;
    clusterLink *link;
    &#x2F;* 和该节点建立连接 *&#x2F;
    fd = anetTcpNonBlockBindConnect(server.neterr, node-&gt;ip,
        node-&gt;cport, NET_FIRST_BIND_ADDR);
    &#x2F;* .... fd 为-1时的异常处理 *&#x2F;
    &#x2F;* 建立 link *&#x2F;
    link = createClusterLink(node);
    link-&gt;fd = fd;
    node-&gt;link = link;
    aeCreateFileEvent(server.el,link-&gt;fd,AE_READABLE,
            clusterReadHandler,link);
    &#x2F;* 向新连接的节点发送 PING 命令，防止节点被识进入下线 *&#x2F;
    &#x2F;* 如果节点被标记为 MEET ，那么发送 MEET 命令，否则发送 PING 命令 *&#x2F;
    old_ping_sent = node-&gt;ping_sent;
    clusterSendPing(link, node-&gt;flags &amp; CLUSTER_NODE_MEET ?
            CLUSTERMSG_TYPE_MEET : CLUSTERMSG_TYPE_PING);
    &#x2F;* .... *&#x2F;
    &#x2F;* 如果当前节点（发送者）没能收到 MEET 信息的回复，那么它将不再向目标节点发送命令。*&#x2F;
    &#x2F;* 如果接收到回复的话，那么节点将不再处于 HANDSHAKE 状态，并继续向目标节点发送普通 PING 命令*&#x2F;
    node-&gt;flags &amp;= ~CLUSTER_NODE_MEET;
}
</code></pre>
<h4 id="防止节点假超时及状态过期"><a href="#防止节点假超时及状态过期" class="headerlink" title="防止节点假超时及状态过期"></a>防止节点假超时及状态过期</h4><p>防止节点假超时和标记疑似下线标记也是在 clusterCron 函数中，具体如下所示。它会检查当前所有的 nodes 节点列表，如果发现某个节点与自己的最后一个 PONG 通信时间超过了预定的阈值的一半时，为了防止节点是假超时，会主动释放掉与之的 link 连接，然后会主动向它发送一个 PING 消息。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-cpp">&#x2F;* cluster.c clusterCron 函数部分，遍历节点来检查 fail 的节点*&#x2F;
while((de = dictNext(di)) != NULL) {
    clusterNode *node = dictGetVal(de);
    now = mstime(); &#x2F;* Use an updated time at every iteration. *&#x2F;
    mstime_t delay;

    &#x2F;* 如果等到 PONG 到达的时间超过了 node timeout 一半的连接 *&#x2F;
    &#x2F;* 因为尽管节点依然正常，但连接可能已经出问题了 *&#x2F;
    if (node-&gt;link &amp;&amp; &#x2F;* is connected *&#x2F;
        now - node-&gt;link-&gt;ctime &gt;
        server.cluster_node_timeout &amp;&amp; &#x2F;* 还未重连 *&#x2F;
        node-&gt;ping_sent &amp;&amp; &#x2F;* 已经发过ping消息 *&#x2F;
        node-&gt;pong_received &lt; node-&gt;ping_sent &amp;&amp; &#x2F;* 还在等待pong消息 *&#x2F;
        &#x2F;* 等待pong消息超过了 timeout&#x2F;2 *&#x2F;
        now - node-&gt;ping_sent &gt; server.cluster_node_timeout&#x2F;2)
    {
        &#x2F;* 释放连接，下次 clusterCron() 会自动重连 *&#x2F;
        freeClusterLink(node-&gt;link);
    }

    &#x2F;* 如果目前没有在 PING 节点*&#x2F;
    &#x2F;* 并且已经有 node timeout 一半的时间没有从节点那里收到 PONG 回复 *&#x2F;
    &#x2F;* 那么向节点发送一个 PING ，确保节点的信息不会太旧，有可能一直没有随机中 *&#x2F;
    if (node-&gt;link &amp;&amp;
        node-&gt;ping_sent == 0 &amp;&amp;
        (now - node-&gt;pong_received) &gt; server.cluster_node_timeout&#x2F;2)
    {
        clusterSendPing(node-&gt;link, CLUSTERMSG_TYPE_PING);
        continue;
    }
    &#x2F;* .... 处理failover和标记遗失下线 *&#x2F;
}
</code></pre>
<h4 id="处理failover和标记疑似下线"><a href="#处理failover和标记疑似下线" class="headerlink" title="处理failover和标记疑似下线"></a>处理failover和标记疑似下线</h4><p>如果防止节点假超时处理后，节点依旧未收到目标节点的 PONG 消息，并且时间已经超过了 cluster_node_timeout，那么就将该节点标记为疑似下线状态。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-cpp">&#x2F;* 如果这是一个主节点，并且有一个从服务器请求进行手动故障转移,那么向从服务器发送 PING*&#x2F;
if (server.cluster-&gt;mf_end &amp;&amp;
    nodeIsMaster(myself) &amp;&amp;
    server.cluster-&gt;mf_slave == node &amp;&amp;
    node-&gt;link)
{
    clusterSendPing(node-&gt;link, CLUSTERMSG_TYPE_PING);
    continue;
}

&#x2F;* 后续代码只在节点发送了 PING 命令的情况下执行*&#x2F;
if (node-&gt;ping_sent == 0) continue;

&#x2F;* 计算等待 PONG 回复的时长 *&#x2F; 
delay = now - node-&gt;ping_sent;
&#x2F;* 等待 PONG 回复的时长超过了限制值，将目标节点标记为 PFAIL （疑似下线)*&#x2F;
if (delay &gt; server.cluster_node_timeout) {
    &#x2F;* 超时了，标记为疑似下线 *&#x2F;
    if (!(node-&gt;flags &amp; (REDIS_NODE_PFAIL|REDIS_NODE_FAIL))) {
        redisLog(REDIS_DEBUG,&quot;*** NODE %.40s possibly failing&quot;,
            node-&gt;name);
        &#x2F;&#x2F; 打开疑似下线标记
        node-&gt;flags |= REDIS_NODE_PFAIL;
        update_state = 1;
    }
}
</code></pre>
<h4 id="实际发送Gossip消息"><a href="#实际发送Gossip消息" class="headerlink" title="实际发送Gossip消息"></a>实际发送Gossip消息</h4><p>以下是前方多次调用过的clusterSendPing()方法的源码，代码中有详细的注释，大家可以自行阅读。主要的操作就是将节点自身维护的 clusterState 转换为对应的消息结构体，。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-cpp">&#x2F;* 向指定节点发送一条 MEET 、 PING 或者 PONG 消息 *&#x2F;
void clusterSendPing(clusterLink *link, int type) {
    unsigned char *buf;
    clusterMsg *hdr;
    int gossipcount = 0; &#x2F;* Number of gossip sections added so far. *&#x2F;
    int wanted; &#x2F;* Number of gossip sections we want to append if possible. *&#x2F;
    int totlen; &#x2F;* Total packet length. *&#x2F;
    &#x2F;&#x2F; freshnodes 是用于发送 gossip 信息的计数器
    &#x2F;&#x2F; 每次发送一条信息时，程序将 freshnodes 的值减一
    &#x2F;&#x2F; 当 freshnodes 的数值小于等于 0 时，程序停止发送 gossip 信息
    &#x2F;&#x2F; freshnodes 的数量是节点目前的 nodes 表中的节点数量减去 2 
    &#x2F;&#x2F; 这里的 2 指两个节点，一个是 myself 节点（也即是发送信息的这个节点）
    &#x2F;&#x2F; 另一个是接受 gossip 信息的节点
    int freshnodes = dictSize(server.cluster-&gt;nodes)-2;

    
    &#x2F;* 计算要携带多少节点的信息，最少3个，最多 1&#x2F;10 集群总节点数量*&#x2F;
    wanted = floor(dictSize(server.cluster-&gt;nodes)&#x2F;10);
    if (wanted &lt; 3) wanted = 3;
    if (wanted &gt; freshnodes) wanted = freshnodes;

    &#x2F;* .... 省略 totlen 的计算等*&#x2F;

    &#x2F;* 如果发送的信息是 PING ，那么更新最后一次发送 PING 命令的时间戳 *&#x2F;
    if (link-&gt;node &amp;&amp; type == CLUSTERMSG_TYPE_PING)
        link-&gt;node-&gt;ping_sent = mstime();
    &#x2F;* 将当前节点的信息（比如名字、地址、端口号、负责处理的槽）记录到消息里面 *&#x2F;
    clusterBuildMessageHdr(hdr,type);

    &#x2F;* Populate the gossip fields *&#x2F;
    int maxiterations = wanted*3;
    &#x2F;* 每个节点有 freshnodes 次发送 gossip 信息的机会
       每次向目标节点发送 2 个被选中节点的 gossip 信息（gossipcount 计数） *&#x2F;
    while(freshnodes &gt; 0 &amp;&amp; gossipcount &lt; wanted &amp;&amp; maxiterations--) {
        &#x2F;* 从 nodes 字典中随机选出一个节点（被选中节点） *&#x2F;
        dictEntry *de = dictGetRandomKey(server.cluster-&gt;nodes);
        clusterNode *this = dictGetVal(de);

        &#x2F;* 以下节点不能作为被选中节点：
         * Myself:节点本身。
         * PFAIL状态的节点
         * 处于 HANDSHAKE 状态的节点。
         * 带有 NOADDR 标识的节点
         * 因为不处理任何 Slot 而被断开连接的节点 
         *&#x2F;
        if (this == myself) continue;
        if (this-&gt;flags &amp; CLUSTER_NODE_PFAIL) continue;
        if (this-&gt;flags &amp; (CLUSTER_NODE_HANDSHAKE|CLUSTER_NODE_NOADDR) ||
            (this-&gt;link == NULL &amp;&amp; this-&gt;numslots == 0))
        {
            freshnodes--; &#x2F;* Tecnically not correct, but saves CPU. *&#x2F;
            continue;
        }

        &#x2F;&#x2F; 检查被选中节点是否已经在 hdr-&gt;data.ping.gossip 数组里面
        &#x2F;&#x2F; 如果是的话说明这个节点之前已经被选中了
        &#x2F;&#x2F; 不要再选中它（否则就会出现重复）
        if (clusterNodeIsInGossipSection(hdr,gossipcount,this)) continue;

        &#x2F;* 这个被选中节点有效，计数器减一 *&#x2F;
        clusterSetGossipEntry(hdr,gossipcount,this);
        freshnodes--;
        gossipcount++;
    }

    &#x2F;* .... 如果有 PFAIL 节点，最后添加 *&#x2F;


    &#x2F;* 计算信息长度 *&#x2F;
    totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
    totlen += (sizeof(clusterMsgDataGossip)*gossipcount);
    &#x2F;* 将被选中节点的数量（gossip 信息中包含了多少个节点的信息）记录在 count 属性里面*&#x2F;
    hdr-&gt;count = htons(gossipcount);
    &#x2F;* 将信息的长度记录到信息里面 *&#x2F;
    hdr-&gt;totlen = htonl(totlen);
    &#x2F;* 发送网络请求 *&#x2F;
    clusterSendMessage(link,buf,totlen);
    zfree(buf);
}


void clusterSetGossipEntry(clusterMsg *hdr, int i, clusterNode *n) {
    clusterMsgDataGossip *gossip;
    &#x2F;* 指向 gossip 信息结构 *&#x2F;
    gossip = &amp;(hdr-&gt;data.ping.gossip[i]);
    &#x2F;* 将被选中节点的名字记录到 gossip 信息 *&#x2F;   
    memcpy(gossip-&gt;nodename,n-&gt;name,CLUSTER_NAMELEN);
    &#x2F;* 将被选中节点的 PING 命令发送时间戳记录到 gossip 信息 *&#x2F;
    gossip-&gt;ping_sent = htonl(n-&gt;ping_sent&#x2F;1000);
    &#x2F;* 将被选中节点的 PONG 命令回复的时间戳记录到 gossip 信息 *&#x2F;
    gossip-&gt;pong_received = htonl(n-&gt;pong_received&#x2F;1000);
    &#x2F;* 将被选中节点的 IP 记录到 gossip 信息 *&#x2F;
    memcpy(gossip-&gt;ip,n-&gt;ip,sizeof(n-&gt;ip));
    &#x2F;* 将被选中节点的端口号记录到 gossip 信息 *&#x2F;
    gossip-&gt;port = htons(n-&gt;port);
    gossip-&gt;cport = htons(n-&gt;cport);
    &#x2F;* 将被选中节点的标识值记录到 gossip 信息 *&#x2F;
    gossip-&gt;flags = htons(n-&gt;flags);
    gossip-&gt;notused1 = 0;
}
</code></pre>
<p>下面是 clusterBuildMessageHdr 函数，它主要负责填充消息结构体中的基础信息和当前节点的状态信息。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-c">&#x2F;* 构建消息的 header *&#x2F;
void clusterBuildMessageHdr(clusterMsg *hdr, int type) {
    int totlen = 0;
    uint64_t offset;
    clusterNode *master;

    &#x2F;* 如果当前节点是salve，则master为其主节点，如果当前节点是master节点，则master就是当前节点 *&#x2F;
    master = (nodeIsSlave(myself) &amp;&amp; myself-&gt;slaveof) ?
              myself-&gt;slaveof : myself;

    memset(hdr,0,sizeof(*hdr));
    &#x2F;* 初始化协议版本、标识、及类型， *&#x2F;
    hdr-&gt;ver = htons(CLUSTER_PROTO_VER);
    hdr-&gt;sig[0] = &#39;R&#39;;
    hdr-&gt;sig[1] = &#39;C&#39;;
    hdr-&gt;sig[2] = &#39;m&#39;;
    hdr-&gt;sig[3] = &#39;b&#39;;
    hdr-&gt;type = htons(type);
    &#x2F;* 消息头设置当前节点id *&#x2F;
    memcpy(hdr-&gt;sender,myself-&gt;name,CLUSTER_NAMELEN);

    &#x2F;* 消息头设置当前节点ip *&#x2F;
    memset(hdr-&gt;myip,0,NET_IP_STR_LEN);
    if (server.cluster_announce_ip) {
        strncpy(hdr-&gt;myip,server.cluster_announce_ip,NET_IP_STR_LEN);
        hdr-&gt;myip[NET_IP_STR_LEN-1] = &#39;\0&#39;;
    }

    &#x2F;* 基础端口及集群内节点通信端口 *&#x2F;
    int announced_port = server.cluster_announce_port ?
                         server.cluster_announce_port : server.port;
    int announced_cport = server.cluster_announce_bus_port ?
                          server.cluster_announce_bus_port :
                          (server.port + CLUSTER_PORT_INCR);
    &#x2F;* 设置当前节点的槽信息 *&#x2F;
    memcpy(hdr-&gt;myslots,master-&gt;slots,sizeof(hdr-&gt;myslots));
    memset(hdr-&gt;slaveof,0,CLUSTER_NAMELEN);
    if (myself-&gt;slaveof != NULL)
        memcpy(hdr-&gt;slaveof,myself-&gt;slaveof-&gt;name, CLUSTER_NAMELEN);
    hdr-&gt;port = htons(announced_port);
    hdr-&gt;cport = htons(announced_cport);
    hdr-&gt;flags = htons(myself-&gt;flags);
    hdr-&gt;state = server.cluster-&gt;state;

    &#x2F;* 设置 currentEpoch and configEpochs. *&#x2F;
    hdr-&gt;currentEpoch = htonu64(server.cluster-&gt;currentEpoch);
    hdr-&gt;configEpoch = htonu64(master-&gt;configEpoch);

    &#x2F;* 设置复制偏移量 *&#x2F;
    if (nodeIsSlave(myself))
        offset = replicationGetSlaveOffset();
    else
        offset = server.master_repl_offset;
    hdr-&gt;offset = htonu64(offset);

    &#x2F;* Set the message flags. *&#x2F;
    if (nodeIsMaster(myself) &amp;&amp; server.cluster-&gt;mf_end)
        hdr-&gt;mflags[0] |= CLUSTERMSG_FLAG0_PAUSED;

    &#x2F;* 计算并设置消息的总长度 *&#x2F;
    if (type == CLUSTERMSG_TYPE_FAIL) {
        totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
        totlen += sizeof(clusterMsgDataFail);
    } else if (type == CLUSTERMSG_TYPE_UPDATE) {
        totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
        totlen += sizeof(clusterMsgDataUpdate);
    }
    hdr-&gt;totlen = htonl(totlen);
}
</code></pre>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本来只想写一下 Redis Cluster 的 Gossip 协议，没想到文章越写，内容越多，最后源码分析也是有点虎头蛇尾，大家就凑合看一下，也希望大家继续关注我后续的问题。</p>
<p><a href="http://remcarpediem.net/">个人博客，欢迎来玩</a></p>
<p><img src="http://cdn.remcarpediem.net/2020-05-26-144752.png" alt=""></p>

                </div>
                    
        <footer class="article-footer">
            
                <!-- id 将作为查询条件 -->
                <span id="/article/933c5a3a/" class="leancloud_visitors" data-flag-title="一万字详解 Redis Cluster Gossip 协议">
                    <em class="post-meta-item-text">阅读量 </em>
                    <i class="leancloud-visitors-count">1000</i>
                </span>
             
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/933c5a3a/" data-id="cklaxrk01006dxdseu4d6yimv" class="article-share-link"><i class="fa fa-share"></i>Compartir</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/article/89dcb81b/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Más nuevo</strong>
            <div class="article-nav-title">
                
                    编程小技巧之 Linux 文本处理命令（二）
                
            </div>
        </a>
    
    
        <a href="/article/cd0b2c21/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Más viejo</strong>
            <div class="article-nav-title">MySQL的join功能弱爆了?</div>
        </a>
    
</nav>


    
</article>


    
    
        <section id="comments">
    <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
    <div id="vcomments"></div>
    <script>
        new Valine({
            el: '#vcomments',
            app_id: 'Py2W9ndz8WJGDduj0id77Yq7-gzGzoHsz',
            app_key: 'cTJCvL6VOQL5ozXfABqDbAyP',
            placeholder: '欢迎大家积极留言交流',
            visitor: true
        })
    </script>
</section>
    

</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">Recientes</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/699640c9/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/article/699640c9/" class="title">为什么 ElasticSearch 比 MySQL 更适合复杂条件搜索</a></p>
                            <p class="item-date"><time datetime="2021-02-18T14:00:30.000Z" itemprop="datePublished">2021-02-18</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/89dcb81b/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/article/89dcb81b/" class="title">编程小技巧之 Linux 文本处理命令（二）</a></p>
                            <p class="item-date"><time datetime="2021-01-27T14:23:46.000Z" itemprop="datePublished">2021-01-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/933c5a3a/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/article/933c5a3a/" class="title">一万字详解 Redis Cluster Gossip 协议</a></p>
                            <p class="item-date"><time datetime="2020-12-02T15:03:11.000Z" itemprop="datePublished">2020-12-02</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/cd0b2c21/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/article/cd0b2c21/" class="title">MySQL的join功能弱爆了?</a></p>
                            <p class="item-date"><time datetime="2020-11-10T15:08:23.000Z" itemprop="datePublished">2020-11-10</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/2245b524/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/article/2245b524/" class="title">MySQL死锁系列-线上死锁问题排查思路</a></p>
                            <p class="item-date"><time datetime="2020-09-28T15:18:42.000Z" itemprop="datePublished">2020-09-28</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">Categorias</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SICP/">SICP</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java-persistent/">java persistent</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/plan/">plan</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发/">并发</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂记/">杂记</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计/">设计</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">2</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">Archivos</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">3</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">Nube de etiquetas</h3>
        <div class="widget tagcloud">
            <a href="/tags/AOP/" style="font-size: 12.5px;">AOP</a> <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Animation/" style="font-size: 10px;">Animation</a> <a href="/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GSON/" style="font-size: 10px;">GSON</a> <a href="/tags/JSON/" style="font-size: 10px;">JSON</a> <a href="/tags/JUC/" style="font-size: 15px;">JUC</a> <a href="/tags/Jenkins/" style="font-size: 10px;">Jenkins</a> <a href="/tags/Material-Design/" style="font-size: 10px;">Material Design</a> <a href="/tags/MotionEvent/" style="font-size: 10px;">MotionEvent</a> <a href="/tags/MySQL/" style="font-size: 20px;">MySQL</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/OkHttp/" style="font-size: 12.5px;">OkHttp</a> <a href="/tags/Raft/" style="font-size: 10px;">Raft</a> <a href="/tags/React-Native/" style="font-size: 10px;">React Native</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/RxJava/" style="font-size: 10px;">RxJava</a> <a href="/tags/SICP/" style="font-size: 10px;">SICP</a> <a href="/tags/Shader/" style="font-size: 10px;">Shader</a> <a href="/tags/Span/" style="font-size: 12.5px;">Span</a> <a href="/tags/Spring-Boot/" style="font-size: 12.5px;">Spring Boot</a> <a href="/tags/TCP/" style="font-size: 12.5px;">TCP</a> <a href="/tags/TCP-IP/" style="font-size: 15px;">TCP/IP</a> <a href="/tags/View/" style="font-size: 12.5px;">View</a> <a href="/tags/View-Architecture/" style="font-size: 10px;">View Architecture</a> <a href="/tags/ViewRoot/" style="font-size: 10px;">ViewRoot</a> <a href="/tags/Window机制/" style="font-size: 10px;">Window机制</a> <a href="/tags/animation/" style="font-size: 10px;">animation</a> <a href="/tags/cas/" style="font-size: 10px;">cas</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/draw/" style="font-size: 10px;">draw</a> <a href="/tags/epoll/" style="font-size: 10px;">epoll</a> <a href="/tags/filesystem/" style="font-size: 10px;">filesystem</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/kubernetes/" style="font-size: 10px;">kubernetes</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/mysql/" style="font-size: 12.5px;">mysql</a> <a href="/tags/persistent/" style="font-size: 12.5px;">persistent</a> <a href="/tags/redis/" style="font-size: 17.5px;">redis</a> <a href="/tags/scroll/" style="font-size: 12.5px;">scroll</a> <a href="/tags/spring-cloud/" style="font-size: 10px;">spring-cloud</a> <a href="/tags/事件传递/" style="font-size: 12.5px;">事件传递</a> <a href="/tags/依赖注入/" style="font-size: 10px;">依赖注入</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/动态编程/" style="font-size: 10px;">动态编程</a> <a href="/tags/反射/" style="font-size: 10px;">反射</a> <a href="/tags/图像处理/" style="font-size: 10px;">图像处理</a> <a href="/tags/实习/" style="font-size: 10px;">实习</a> <a href="/tags/工具/" style="font-size: 12.5px;">工具</a> <a href="/tags/工具-Linux/" style="font-size: 10px;">工具, Linux</a> <a href="/tags/市场/" style="font-size: 10px;">市场</a> <a href="/tags/并发/" style="font-size: 10px;">并发</a> <a href="/tags/思维/" style="font-size: 10px;">思维</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/文件系统/" style="font-size: 10px;">文件系统</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/注解/" style="font-size: 15px;">注解</a> <a href="/tags/第三方库/" style="font-size: 12.5px;">第三方库</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/读书/" style="font-size: 10px;">读书</a> <a href="/tags/贪婪算法/" style="font-size: 10px;">贪婪算法</a> <a href="/tags/软件设计/" style="font-size: 10px;">软件设计</a> <a href="/tags/锁/" style="font-size: 10px;">锁</a> <a href="/tags/限流/" style="font-size: 12.5px;">限流</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">Links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://www.blueskykong.com/">aoho blog</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2021 历小冰<br>
            <a href="https://beian.miit.gov.cn">鲁ICP备19003047号</a> 
        </div>
    </div>
</footer>
        
    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
    



<link rel="stylesheet" href="/css/prism.css">
<script type="text/javascript" src="/js/prism.js"></script>
<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>